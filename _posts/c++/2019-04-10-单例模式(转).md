---
layout: post
comments: true
categories: c++
---
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
      inlineMath: [['$','$']]
    }
  });
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>

## 设计模式：单例模式

> 单例模式是最常用到的设计模式之一。一般单例模式分两种：饿汉式和懒汉式两种。
>
> 懒汉式：就是说当第一次使用时才创建一个唯一的实例对象，从而让实现延迟加载的现象。
>
> 饿汉式：就是说不管你将来用不用，程序启动时就创一个唯一的实例对象。
>
> ### 1.简介
>
> 单例模式是一种常用的软件设计模式，其定义是单例对象那个的类智能允许一个实例的存在。对整个系统值设计一个全局对象，这样有利于我们协调系统整体的行为。
>
> ex.在某一个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象在通过这个单例对象获取这些配置信息，这样简化了在复杂环境下的配置管理。
>
> ### 2.实现思路
>
> 单例模式要求能够有返回对象一个引用（永远是同一个）和一个获得该实例的方法（必须是静态方法，通常用getInstance这个名称）。
>
> 单例的实现主要是通过以下两个步骤：
>
> ​	1.将该类的构造方法定义为私有方法，这样其他处的代码就无法通过该类的构造方法来实例化该类的对象，只有通过该类提供的静态方法来德奥该类的唯一实例。
>
> ​	2.在该类提供一个静态方法，当我们调用这个方法时，如果累所持有的引用不为空就返回这个引用，如果该类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用。
>
> ### 3.注意事项
>
> 单例模式在多线程模式的应用场合下必须小心使用。如果唯一实例尚未创建时，有两个线程同时调用创建方法，那么他们同时没有开率到唯一实例的存在，从而同时各自创建了一个实例，这样就有两个实例被构造出来，从而违背了单例模式中实例唯一的原则，解决问题的办法是为只是类是否已经实例化的变量提供一个互斥锁。
>
> ### 4.典型实现方式
>
> #### 4.1简单单例模式实现
>
> ~~~c++
> #include <iostream>
> #include <thread>
> using namespace std;
> 
> class Singleton{
> private:
> 	Singleton(){};
> 	static Singleton*single;
> public:
> 	static Singleton*GetSingleton();
> };
> 
> Singleton*Singleton::single=nullptr;
> 
> Singleton*Singleton::GetSingleton(){
> 	if (single==nullptr)
> 	{
> 		single=new Singleton;
> 	}
> 	return single;
> }
> 
> int main(int argc,const char*argv[])
> {
> 	//只有我们调用Getsingleton时，类才会new出对象
> 	Singleton *s1=Singleton::GetSingleton();
> 	Singleton *s2=Singleton::GetSingleton();
> 	if (s1==s2)
> 	{
> 		cout<<"s1==s2"<<endl; //输出s1 == s2
> 	}
> 	else
> 	{
> 		cout<<"s1!=s2"<<endl;
> 	}
> 	return 0;
> }
> ~~~
>
> #### 4.2懒汉式单例模式
>
> 懒汉：不到万不得已就不会去实例化类，也就是说在第一次用到类实例的时候才会去实例化。与之对应的是饿汉式单例。
>
> ~~~c++
> class Singleton
> {
> private:
> 	Singleton()
> 	{
> 		m_count ++;
> 		printf("Singleton begin\n");
> 		Sleep(1000);
> 		printf("Singleton end\n");
> 	}
> 	static Singleton*single;
> public:
> 	static Singleton *Getsingleton();
> 	static void print();
> 	static int m_count;
> };
> 
> Singleton *Singleton::single=nullptr;
> int Singleton::m_count=0;
> 
> Singleton*Singleton::Getsingleton(){
> 	if (single==nullptr)
> 	{
> 		single=new Singleton;
> 	}
> 	return single;
> }
> 
> void Singleton::print()
> {
> 	cout<<m_count<<endl;
> }
> 
> //回调函数
> void threadFunc(void *p){
> 	DWORD id = GetCurrentThreadId(); //获得线程id
>      cout<<id<<endl;
> 	Singleton::Getsingleton()->print(); //构造函数并获得实例，调用静态成员函数
> }
> 
> int main(int argc,const char*argv[]){
> 	int threadNum=3;
> 	HANDLE threadHdl[100];
> 
> 	//创建三个进程
> 	for (int i = 0; i < threadNum; i++)
> 	{
> 		threadHdl[i]=(HANDLE)_beginthread(threadFunc,0,nullptr);
> 	}
> 
> 	//让主线程等待所有的线程结束后在退出
> 	for (int i = 0; i < threadNum; i++)
> 	{
> 		WaitForSingleObject(threadHdl[i],INFINITE);
> 	}
> 	cout<<"main"<<endl;   //验证主进程是否最后退出
> 	system("pause");
> 	return 0;
> }
> ~~~
>
> #### 4.3饿汉式单例模式
>
> ~~~c++
> class Singleton
> {
> private:
> 	Singleton()
> 	{
> 		m_count++;
> 		printf("Singleton begin\n");
> 		Sleep(1000);
> 		printf("Singleton end\n");
> 	}
> 	static Singleton *single;
> public:
> 	static Singleton *GetSingleton();
> 	static void print();
> 	static int m_count;
> };
> 
> //饿汉式的关键，初始化即实例化
> Singleton *Singleton::single=new Singleton;
> int Singleton::m_count=0;
> 
> Singleton*Singleton::GetSingleton()
> {
> 	//不需要进行实例化
> 	return single;
> }
> 
> void Singleton::print()
> {
> 	cout<<m_count<<endl;
> }
> 
> //回调函数
> void threadFunc(void *p)
> {
> 	DWORD id = GetCurrentThreadId(); //获得线程id
> 	cout<<id<<endl;
> 	Singleton::GetSingleton()->print(); //构造函数并获得实例，调用静态函数成员
> }
> 
> int main(int argc,const char*argv[])
> {
> 	int threadNum=3;
> 	HANDLE threadHdl[100];
> 
> 	//创建3个进程
> 	for (int i = 0; i < threadNum; i++)
> 	{
> 		threadHdl[i] = (HANDLE)_beginthread(threadFunc,0,nullptr);
> 	}
> 
> 	//让进程等待所有的线程结束后在退出
> 	for (int i = 0; i < threadNum; i++)
> 	{
> 		WaitForSingleObject(threadHdl[i],INFINITE);
> 	}
> 	cout<<"main"<<endl;
> 	system("pause");
> 	return 0;
> }
> ~~~
>
> #### 4.4 线程安全的懒汉式单例的实现
>
> 饿汉式会提前浪费我们的内存空间以及资源，如果有为项目中要求我们在使用到实例的时候再去实例化，则还是需要使用懒汉式。

~~~
class singleton
{
protected:
    singleton()
    {
        pthread_mutex_init(&mutex);
    }
public:
    static pthread_mutex_t mutex;
    static singleton* initance();
    int a;
};

pthread_mutex_t singleton::mutex;
singleton* singleton::initance()
{
    pthread_mutex_lock(&mutex);
    static singleton obj;
    pthread_mutex_unlock(&mutex);
    return &obj;
}
~~~

#### 4.5饿汉模式

饿汉模式实现单例模式是安全的

~~~
class singleton
{
protected:
    singleton()
    {}
private:
    static singleton* p;
public:
    static singleton* initance();
};
singleton* singleton::p = new singleton;
singleton* singleton::initance()
{
    return p;
}
~~~



















