---
layout: post
comments: true
categories: Cplus
---
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
      inlineMath: [['$','$']]
    }
  });
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
## c++多线程

多线程：**并行**和**并发**，多线程是实现并发（并行）的一种手段。并行是指两个或多个独立的操作同时进行。不同于并发，在一个时间段内执行多个操作。在单核时代，多个线程是并发的。在一个时间段内轮流执行；在多核时代，多个线程可以实现真正的并行没在多核上真正独立的并行执行。

**多进程并发**

使用多线程并发是将一个应用程序划分为多个独立的进程（每个进程只有一个线程），这些独立的进程间可以相互通信共同完成任务。由于操作系统对进程提供了大量的保护机制，以避免一个进程修改了另一个进程的数据，使用多进程比多线程更容易写出安全的代码。但是也造就了多线程并发的两个缺点：

* 在进程间的通信，无论是使用信号。套接字，还是文件，管道等方式，其使用要么比较复杂，要么就是速度比较慢或者两者兼而得之。

* 运行多个线程的开销很大，操作系统要分配很多的资源来对这些进程进行管理。

**多线程并发**

多线程并发是指在同一个进程中执行多个线程，线程是轻量级的进程，每个线程可以相互独立的运行不同的指令序列，但是线程不独立的拥有资源，一拉与创建它的进程而存在，统一进程中多个线程共享相同的地址空间们可以访问进程中的大部分数据，指针和引用可以在线程中进行传递。这样，同意进程中的多个线程能够很方便的进行数据共享以及通信，也就比进程更适用于并发操作。由于缺少操作系统提供的保护机制，在多线程共享数据以及通信时，需要程序员做更多的工作已保证共享数据的操作是以预想的操作顺序进行的，并且要极力的避免死锁。

### 1.线程介绍

~~~c++
#include<thread>
#include <iostream>
using namespace std;

void output(int i)
{
	cout<<i<<endl;
}

int main()
{
	for (uint8_t i = 0; i < 4; i++)
	{
		thread t(output,i);
		t.detach();
	}

	getchar();
	system("pause");
	return 0;
}
~~~

输出结果：

按照正常的输出顺序：

~~~
0\n 1\n 2\n 3\n
~~~

出现如下情况：![1554886551826](https://raw.githubusercontent.com/MaoChengEr/maochenger.github.io/master/imgs/1554886551826.png)



首先输出的是01，紧接着输出2,。cou有四核，但是控制台只有一个，同时只能有一个线程拥有这个唯一的控制台，将数字输出。

参照上面的执行结果，控制台的拥有转移权如下：

* $t_0$拥有控制台，输出了数字0，但是其没有来得及输出换行符，控制台的同游权缺转移到了$t_1$（0）
* $t_1$完成自己的输出，$t_1$线程完成（1\n）
* $t_2$拥有控制台，完成输出 (2\n)
* 控制台拥有权转移给$t_0$，完成换行符(\n)
* $t_3​$拥有控制台，完成输出(3\n)

由于控制台是系统资源，这里控制台拥有权是管理操作系统完成的。但是，假如是多个线程共享进程空间的数据，这就需要自己写代码控制，每个线程何时能够拥有共享数据进行操作，**共享数据的管理以及线程间的通信**，是多线程编程的两大核心。

### 2.线程管理

每个应用程序至少有一个进城，而每个进程至少有一个主线程，除了主线程外，在一个进程中还可以创建多个线程，每个线程都需要一个入口函数，入口函数返回退出；该线程也会退出，主线程就是以main函数作为入口函数的线程。在c++11的线程库中，将线程的管理在类std::thread中，使用std::thread可以创建，启动一个线程，并可以将线程挂起、结束等操作。

#### 2.1启动一个线程

c++11的线程库启动一个线程是非常简单的，只需要创建一个std::thread对象，就会启动一个线程，并使用该线程std::thread对象来管理该线程。

~~~c++
do_task();
std::thread(do_task);
~~~

这里创建std::thread传入的函数，实际上其构造函数需要可调用(callback)类型，只要函数调用类型的实例都是可以的，所有除了传递函数外，还可以使用:：lambda表达式

使用lambda表达式启动线程输出数字

~~~c++
for(int i =0;i<4;i++)
{
    thread t([i]{
        cout<<i<<endl;
    });
    t.detach();
}
~~~

重载了()运算符类的实例

使用重载了()运算符的类实现多个线程数字输出

~~~c++
class Task
{
public:
	void operator()(int i)
	{
		cout<<i<<endl;
	}
};

int main()
{
	for (uint8_t i = 0; i < 4; i++)
	{
		Task task;
		thread t(task,i);
		t.detach();
	}
	return 0;
}
~~~

把函数对象传入std::thread的构造函数时，要注意一个C++的语法解析错误（C++‘s most vexing parse）.向std::thread的构造函数中传入的是一个临时变量，而不是命名变量就会出现语法解析错误。如下代码：

~~~c++
std::thread t(Task());
~~~

这里相当于生命了一个函数t，其返回类型为thread，而不是启动一个新的线程。可以使用新的初始化语法避免这种情况

~~~c++
std::thread t{Task()};
~~~

当线程启动后，一定要在和线程相关的thread销毁前，确定以何种方式等待线执行结束。

C++有两种方式等待线程结束

* detach方式，启动的线程自主在后台运行，当前的代码继续往下执行，不等待新县城结束。前面代码所使用的就是这种方式。
* join当时，等待启动的线程完成，才会继续往下执行。加入前面的代码使用这种当时，其输出就会0,1,2,3，因为每次都是前一个线程输出完成了才会进行下一个循环，启动下一个新线程。

无论在何种情形，一定要在thread销毁前，调用t.join或者t.detach，来决定线程以何种方式运行。当使用join方式时，会阻塞当前代码，等待线程完成退出后，才会继续向下进行。而detach方式则不会对当前的代码造成影响，当前代码继续向下执行，创建的新线程同时并发执行，这时候需要特别注意：创建的新线程对当前作用于的变量的使用，创建新线程的作用域结束后，有可能线程仍在执行，这是局部变量随着作用于的完成都已销毁，如果线程继续使用局部变量的引用或者指针，会出现意想不到的错误，并且这种错误很难排查。例如：

~~~c++
auto fn=[](int *a)
{
    for(int i =0;i<10;i++)
    {
        cout<<*a<<endl;
    }
};
[]
{
	int a = 100;
	
	thread t(fn,&a);
	
	t.detach();
}();
~~~

在lambda表达式中，使用fn启动了一个新的线程，在新的线程中使用了局部变量a的指针，并且将该线程的运行方向设置为detach。这样lambda表达式在执行结束后，变量a被销毁，但是在后台运行的此案城仍然在使用以销毁变量a的指针，其输出结果如下：









































