---
layout: post
comments: true
categories: c++
---
## c++关键字总结(不定期更新)

### 1.explicit

**explicit**：可以抑制内置类型隐式转换,所以在类的构造函数中,最好尽可能多用explicit关键字,防止不必要的隐式转换.

~~~c++
#inlude<iostream>
using namespace std;

class A
{
public:
    //这里的关键词来修饰类构造函数
    explicit A(int i=5,int j=10)
    {
        m_a=i;
        m_b=j;
    }
private:
    int m_a;
    int m_b;
};

int main()
{
    A s;
    //这样直接赋值会被提示错误，因为explicit抑制隐式转换的进行
    s = 10；
    s = A(20);
    system("pause");
    return 0;
}
~~~

### 2.string::npos

2.1**npos**是一个常数，表示size_t的最大值（Maximum value for size_t）。许多容器都提供这个东西，用来表示不存在的位置，类型一般是std::container_type::size_type。

~~~c++
#include <iostream>    
#include <limits>    
#include <string>    
using namespace std;    
    
int main()    
{    
    size_t npos = -1;    
    cout << "npos: " << npos << endl;    
    cout << "size_t max: " << numeric_limits<size_t>::max() << endl;  
}
~~~


执行结果为：![1554866090719](C:/Users/Fred/AppData/Roaming/Typora/typora-user-images/1554866090719.png)

2.2 **npos**可以表示string的结束位子，是string::type_size 类型的，也就是find（）返回的类型。find函数在找不到指定值得情况下会返回string::npos。举例如下（计算字符串中含有的不同字符的个数）：

~~~
int main()
{
    string b;
	getline(cin,b);
	int count=0;
	for (int i = 0; i < 127; i++)
	{
		if (b.find(i)!=string::npos)
		{
			count++;
		}
	}
	cout<<count;
}
~~~

2.3 **string::npos**作为string的成员函数的一个长度参数时，表示“直到字符串结束（until the end of the string）”。

~~~c++
int main()
{  
   	string filename="test.cpp";
	cout<<"filename:"<<filename<<endl;

	size_t idx=filename.find('.'); //as a return value
	if (idx == string::npos)
	{
		cout<<" filename does not contain any period!"<<endl;
	}
	else
	{
		string tmpname=filename;
		tmpname.replace(idx+1,string::npos,"xxx");//string::npos作为长度参数，表示直到字符串结束
		cout<<"replace:"<<tmpname<<endl;
	} 
}
~~~

2.4 **notice**

~~~
int idx=str.find("abc");
if(idx==string::npos)
...
~~~

1.上述代码中idx被定义为int，这是错误的，即使定义为unsigned int 也是错误的，它必须定义为string::size_type.因为string::size_type(由自渡船配置器allocator定义)描述的是size,故虚无符号整数型类别。因为缺省配置器以型别size_t作为size_type,于是-1被转换为无符号整数型别，npos也就成为了该类型的最大无符号值。不过实际值还是取决于型别size_type的实际定义。不幸的是这些最大值都不相同，实际中，如果idx的值为-1，由于idx和字符串string::npos型别不同，比较结果可能得到false。要想要判断find()的结果是否为npos，醉倒的办法直接比较：

~~~
if(std::find("abc")==string::npos){...}
~~~

2.string类型提供了6种查找函数，每种函数以不同的形式的find命名。这些操作全部都返回string::size_type类型的值，以下标形式标记查找匹配所发生的位置；或者返回一个名为string::npos的特殊值，说明查找没有匹配。string类将npos定义为保证大于任何有效下标的值。

### 3.DWORD

**DWORD** 代表 unsigned long,word占两个字节，DWORD为double word，占4个字节，每个字节8位，共占32位。

























