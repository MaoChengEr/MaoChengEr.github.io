---
layout: post
comments: true
categories: Cplus
---
### C++之函数重载和运算符重载问题

#### 1.函数重载

> 在同一个作用域内，可以生命几个功能类似的同名函数
> 
> 但是这些同名函数的形式参数（之参数的个数、类型或者顺序）必须不同。
> 
> 不能仅仅通过返回类型的不同来重载函数

~~~c++
class Data
{
public:
	void print(int value)
	{
		std::cout<<"int value:"<<value<<endl;
	}

	void print(double value)
	{
		std::cout<<"double value:"<<value<<std::endl;
	}

	void print(char c[])
	{
		std::cout<<"char value:"<<c<<std::endl;
	}
};

int main()
{
	Data d_;
	int a = 10;
	double b = 30.654;
	char c[6]="hello";

	d_.print(a);
	d_.print(b);
	d_.print(c);

	system("pause");
	return 0;
}
~~~

#### 2.运算符重载

运算符的本质是函数重载

~~~c++
class complex
{
public:
	complex();
	complex(double real, double imag);

public:
	complex operator+(const complex& A) const;
	void display() const;

private:
	double m_real;
	double m_imag;
};

complex::complex() :m_real(0.0), m_imag(0.0) {}
complex::complex(double real, double imag) : m_real(real), m_imag(imag) {}

//运算符重载
complex complex::operator+(const complex& A) const
{
	//complex B;
	//B.m_real = this->m_real + A.m_real;
	//B.m_imag = this->m_imag + A.m_imag;
	//return B;

	//简化
	return complex(this->m_real + A.m_real, this->m_imag + A.m_imag);
}

//显示虚数运算
void complex::display() const
{
	cout << m_real << "+" << m_imag << "i" << endl;
}

void main()
{
	complex c1(4.0, 5.0);
	complex c2(5.0, 4.0);
	complex c3;
	c3 = c1 + c2;
	c3.display();
}
~~~

对于以上$c3=c1+c2$实际上就是

~~~c++
c3=c1.operator+(c2);
~~~











































